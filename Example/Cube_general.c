#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/spi.h"

// SPI Defines
// We are going to use SPI 0, and allocate it to the following GPIO pins
// Pins can be changed, see the GPIO function select table in the datasheet for information on GPIO assignments
#define SPI_PORT spi0
#define PIN_TX 19       // SPI MOSI
#define PIN_SCK 18      // SPI CLK
#define PIN_RCLK 16     // Latch pin for 74HC595

// GPIO Defines
// These pins are used to controll the eight MOSFETs, which controll which layer should light up
// Pin numbers are 6~13, from the bottom to the top
#define PIN_BASED_LAYER 6

// Converse of the High and Low
#define DATA_HIGH 0
#define DATA_LOW 1
#define LAYER_HIGH 1
#define LAYER_LOW 0

uint8_t light[8][8] = {{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
                        };

uint8_t dark[8][8] = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        };

uint8_t temp[8][8] = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        };

uint8_t layer[8][8] = {{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},
                        };

uint8_t number[10][8] = {{0xC3, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xBD, 0xC3},  // 0
                        {0xC3, 0xF7, 0xF7, 0xF7, 0xF7, 0xD7, 0xE7, 0xF7},  // 1
                        {0x81, 0xBF, 0xBF, 0xC3, 0xFD, 0xFD, 0xBD, 0xC3},  // 2
                        {0x83, 0xFD, 0xFD, 0xFD, 0x83, 0xFD, 0xFD, 0x83},  // 3
                        {0xFB, 0xFB, 0xC1, 0xDB, 0xDB, 0xDB, 0xDB, 0xDB},  // 4
                        {0xC3, 0xBD, 0xFD, 0xFD, 0x83, 0xBF, 0xBF, 0x81},  // 5
                        {0xC3, 0xBD, 0xBD, 0xBD, 0x83, 0xBF, 0xBD, 0xC3},  // 6
                        {0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xDD, 0xDD, 0xE3},  // 7
                        {0xC3, 0xBD, 0xBD, 0xBD, 0xC3, 0xBD, 0xBD, 0xC3},  // 8
                        {0xC3, 0xBD, 0xFD, 0xC1, 0xBD, 0xBD, 0xBD, 0xC3}
                        };  // 9

void input_all(uint8_t cube[8][8]);
void moving_number();
void moving_layer();
bool timer_callback_light(repeating_timer_t *rt);
bool timer_callback_dark(repeating_timer_t *rt);
bool timer_callback_moving_layer(repeating_timer_t *rt);

repeating_timer_t timer_light;
repeating_timer_t timer_dark;
repeating_timer_t timer_moving_layer;

int main()
{
    stdio_init_all();

    // SPI initialisation. This example will use SPI at 1MHz.
    spi_init(SPI_PORT, 100000);
    gpio_set_function(PIN_TX, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCK,  GPIO_FUNC_SPI);

    // GPIO initialization.
    gpio_init(PIN_RCLK);
    gpio_set_dir(PIN_RCLK, GPIO_OUT);
    gpio_put(PIN_RCLK, DATA_LOW);       // set to low

    for (int i = 0; i < 8; i++) {
        gpio_init(PIN_BASED_LAYER + i);
        gpio_set_dir(PIN_BASED_LAYER + i, GPIO_OUT);
        gpio_put(PIN_BASED_LAYER + i, 0);      // set to low
    }

    while (true) {
        for (int i = 0; i < 5; i++) {
            add_repeating_timer_ms(16, timer_callback_light, NULL, &timer_light);
            sleep_ms(1000);
            bool cancelled = cancel_repeating_timer(&timer_light);
            add_repeating_timer_ms(16, timer_callback_dark, NULL, &timer_dark);
            sleep_ms(1000);
            cancelled = cancel_repeating_timer(&timer_dark);
        }
        moving_layer();
    }
}

bool timer_callback_light(repeating_timer_t *rt) {
    input_all(light);
    return true;
}

bool timer_callback_dark(repeating_timer_t *rt) {
    input_all(dark);
    return true;
}

bool timer_callback_moving_layer(repeating_timer_t *rt) {
    input_all(layer);
    return true;
}

void input_all(uint8_t cube[8][8]) {
    int i;

    for (i = 0; i < 8; i++) {
        spi_write_blocking(SPI_PORT, cube[i], 8);

        gpio_put(PIN_RCLK, 1);
        busy_wait_us(10);
        gpio_put(PIN_RCLK, 0);

        gpio_put(PIN_BASED_LAYER + i, 1);
        busy_wait_us(300);
        gpio_put(PIN_BASED_LAYER + i, 0);
    }
}

void moving_layer() {
    int i;
    uint8_t one_layer[8] = {0};

    for (i = 0; i < 8; i++)
    {
        memcpy(layer[i], one_layer, sizeof(one_layer));
        add_repeating_timer_ms(16, timer_callback_moving_layer, NULL, &timer_moving_layer);
        sleep_ms(500);
        bool cancelled = cancel_repeating_timer(&timer_moving_layer);
        memcpy(layer, temp, sizeof(temp));
    }
    
}